Λειτουργικά Συστήματα - Προγραμματιστική Άσκηση 2
Μιχαήλ Μπακαλιάνος 
ΑΜ: 1115201700269

Για να τρέξετε το πρόγραμμα , πληκτρολογήστε τα εξής:
	cd src
	make all
	make run 
	
Για να τρέξει το πρόγραμμα με τη χρήση του valgrind  πληκτρολογήστε το εξης:
	make valgrind
	
Παρατηρήσεις:  το πρόγραμμα που επέλεξα για να βρίσκει πρώτους αριθμούς είναι το : και επίσης η λίστα που έχω χρησιμοποιήσει είναι η ίδια λίστα που χρησιμοποίησα και στην Προγραμματιστική Άσκηση 1 του παρόντος μαθήματος , με τη διαφορά ότι έχω προσθέσει μία συνάρτηση η οποία κάνει εισαγωγή στοιχείου με ταξινομημένη σειρα. Το τρίτο πρόγραμμα εύρεσης πρώτον αριθμών που χρησιμοποήσα υλοποιεί τον αλγόριθμο Miller Rabin. Ο εν λόγω αλγόριθμος είναι αποκλειστικά ΔΙΚΟΣ ΜΟΥ , και είναι άσκηση που είχα παραδώσει όταν έδωσα το έτος 2018 το μάθημα Εισαγωγή στον Προγραμματισμό.
Link στο GitHub μου https://github.com/bakalianosm/Find-Prime-Numbers-Program


Σημέιωση : Στο αρχείο αυτό θα βρείτε διαδικαστικά για τον κώδικα που παρέδωσα. Τα πιο τεχνικά θέματα περιγράφονται και στα σχόλια σε κάθε αρχείο. Το συγκεκριμένο πρόγραμμα είναι γραμμένο σε Visual Studio Code και έχει δοκιμαστεί σε Ubuntu 20.04 με gcc 9.3.0 . 


Ημερομηνία παράδοσης: Πέμπτη 19/11/2020.


Γενικά για το αρχείο αυτό:  στο αρχείο αυτό, περιγράφεται η λειτουργικότητα και επεξηγείται ο τρόπος που υιοθέτησα για να υλοποιήσω την άσκηση αυτή. Ξεκινάω το να εξηγω το πρόγραμμα από τα κάτω επίπεδα.Πρώτα από τα φύλλα,μετά συνεχίζω με το ενδιάμεσο επίπεδο και μετα με τον γονέα myprime.


Φύλλα-prime* :  κάθε ένα από τα προγράμματα που αποτελούν τα φύλλα του δέντρου διεργασιων, πέρα από τα ορίσματα γραμμής εντολών που περιγράφουν το διάστημα προς αναζήτηση, απαιτείται να ληφθεί ένα ακόμα όρισμα. Το όρισμα αυτό είναι το fileDescriptor στο οποίο θα γράψει το κάθε prime* τους αριθμους που βρήκε. Μέσα από το  fileDescriptor επιτυγχάνεται η επικοινωνία μεταξύ των επιπέδων  intermediate και prime*. Όπως θα δείτε μέσα στον κώδικα οποιουδήποτε prime*, υπάρχει μια μεταβλητή maxNum. Η τιμή που της έχει αποδωθεί ειναι [κάτω φράγμα] -(μείον) [άνω φράγμα]. Εγώ συνθέτω, όλους τους αριθμούς σε ένα πίνακα και έπειτα στέλνω τον πίνακα μέσα από το pipe. Επειδή απο την αρχή δε γίνεται να ξέρω το μέγεθος του, θεωρώ ότι το μέγεθος είναι όσο το range αριθμών μεταξύ των  [κάτω φράγμα]  και [άνω φράγμα]. Επίσης για κάθε αριθμό που βρέθηκε κρατάω και τον χρόνο που πήρε. Έπειτα τα βάζω σε μια δομή (info) και τα περνάω στον πίνακα που θα στείλω. Ο πίνακας περιλαμβάνει τόσα στοιχεια, όσα το πλήθος των πρώτων αριθμών που βρήκε ο κάθε worker + 1 . Το εξτρα στοιχείο ουσιαστικά, είναι το πλήθος των αριθμών που βρεθήκαν,και πόσο χρόνο πήρε στον worker  να βρεί όλους τους αριθμούς. Μόλις ολοκληρωθεί αυτή η διαδικασία, στέλνεται ο πίνακας από δομές τύπο info στο intermediate που κάλεσε τον αντίστοιχο worker.  Έτσι μετά από το τέλος κάθε worker έχουν επιτευχθεί τα εξής: 
1. Έχω στείλει στον πατέρα (intermediate) μέσω pipe , τους αριθμούς που βρέθηκαν καθώς και πόσο χρόνο πήρε για να βρεθούν καθώς και
2. Πόσους αριθμούς βρήκε ο worker και σε πόσο χρόνο. 


Ενδιάμεσοι κόμβοι -  Intermediate : κάθε ένα από τα προγράμματα που αποτελούν τα φύλλα του δέντρου διεργασιων, πέρα από τα ορίσματα γραμμής εντολών που περιγράφουν το διάστημα προς αναζήτηση, απαιτείται να ληφθεί επίσης
1. ο αριθμός των workers που θα καλέσει ο κάθε intermediate κόμβος
2. το file descriptor στο οποίο θα γράφει τη ταξινομημένη λίστα ( writePipe ) που προέκυψε (και περιλαμβάνει δομές τύπου info) ταξινομημένες κατά αύξουσα σειρά num (επικοινωνία μεταξύ intermediate και myprime). 
3. το file descriptor στο οποίο θα γράφει το πόσο χρόνο χρειάστηκε στο συγκεκριμένο πρόγραμμα ο κάθε worker για να τελειώσει την εκτέλεση του και να βρει τους πρώτους αριθμούς στο πεδίο που του ανατέθηκε(επικοινωνία μεταξύ intermediate και myprime). 
Έπειτα, εφόσον έχουν ληφθεί τα σωστά ορίσματα συνεχίζεται η εκτέλεση του ενδιαμέσου κόμβου.Δημιουργώ pipes τα οποία ειναι για να επικοινωνεί ο κάθε ενδιάμεσος κόμβος με τους worker του. Στη συνέχεια , φτιάχνω τα διαστήματα , μοιράζω τους αριθμούς ανάλογα με το πόσους workers θα έχουμε και καλώ την fork() .
Όσο βρισκόμαστε σε ένα από τα workerNum παιδιά, κλεινουμε τα pipes που δεν θα χρησιμοποιήσουμε και αφήνουμε μόνο αυτό με το οποίο θα πεικοινωνήσει ο τρέχον κόμβος με το φύλλο worker και στη συνέχεια καλούμε τον worker να κάνει τη δουλειά που περιέγραψα παραπάνω.
Όταν τελειώσουμε με τα παιδιά και είμαστε στον πατέρα της διεργασίας, στη συνέχεια της intermediate  με λίγα λόγια , δημιουργώ και αρχικοποιώ όλες τις τιμές τους με 0 , τους παρακάτω πινακες:
1. primeCnt *1D* με θέσεις τόσες όσα τα παιδια.κρατάει πληροφορία για το πόσοι αριθμοί βρέθηκαν από κάθε παιδί και σε πόσο χρόνο
2. info_array  *2D* με τόσες θέσεις όσα τα παιδιά επί το πλήθος [κάτω φράγμα] -(μείον) [άνω φράγμα] . Κρατάει όλα τα ζεύγη (αριθμος,χρόνος που απαιτήθηκε για να βρεθεί) που βρήκε ο καθε worker
Στη συνέχεια κλείνω όλα τα pipes στα οποία ο πατέρας γράφει. Αφήνω ανοιχτά μόνο τα pipes στα οποία θα διαβάσει. Η εκτέλεση συνεχίζεται με το μπλοκ στο οποίο διαβάζω από τα   pipes . Ξεκινάω και τόσες φορές όσο ο αριθμός των workers διαβάζω μόνο το πρώτο ζευγάρι(αριθμος,χρόνος που απαιτήθηκε για να βρεθεί) στο οποίο όπως προανέφερα είναι αποθηκευμένο το συνολο πρώτων που βρήκε ο συγκεκριμένος worker και τον συνολικό χρόνο που απαιτήθηκε. Έπειτα διαβάζω και την υπόλοιπη πληροφορία για όσο απαιτείται και κλεινω τα read pipes. Εφόσον έχουμε τελειώσει με τα παιδιά έχουμε λάβει όλους τους αριθμούς με τους χρόνους τους από τους workers , μένει να συνθέσουμε τη ταξινομημένη λίστα.Δημιουργώ τη λίστα και της εισάγω ένα ένα τα στοιχεια του info array σε αυξουσα σειρα. Εδώ όμως δημιουργείται ένα θέμα. Η λίστα υπάρχει δυναμικά στον address space της διεργασίας που αυτό σημαίνει ότι όταν επιστρέψει η διεργασία στον γονέα της , θα έχει χαθεί ότι έγραψε , οπότε το να κρατάμε έναν pointer  στη λίστα δε μας βοηθάει καθόλου. Επομένως, φτιάχνω, εν ολίγοις ένα αντίγραφο της λίστας, σε πίνακα.Εφόσον η λίστα είναι ταξινομημένη και θα στοιχεία της τα παίρνω ένα προς ένα και τα βάζω στο βοηθητικό πίνακα  ordered_numbers , καταλήγω να έχω έναν ταξινομημένο πίνακα . 
Πάλι στην αρχή του πίνακα αυτού βάζουμε ¨πληροφορία”, αυτή τη φορά το ένα κομμάτι της δομής info είναι χρήσιμο, το πεδίο num ,στο οποίο κρατάμε το αληθινό μέγεθος του πίνακα.
Από εκεί και πέρα το πρόγραμμα ενδιάμεσου κόμβου έχει τελειώσει, δεν έχουν μείνει άλλες δουλειές να κάνει , επομένως γράφει στα αντίστοιχα pipes τα εξής:
1. τους χρόνους εκτέλεσης των workers
2. τον ταξινομημένο πίνακα από ζεύγη (αριθμος,χρόνος που απαιτήθηκε για να βρεθεί) .
Τέλος αποδεσμεύομε την μνήμη που δεσμεύσαμε δυναμικά .


Κόμβος ρίζα - myprime: το πρόγραμμα που αποτελεί τη ρίζα του παρόντος δέντρου διεργασιών , αρχικά λαμβάνει τα ορίσματα χρησιμοποιώντας μια συνάρτηση που έχω φτιάξει και στη συνέχεια δημιουργεί τα  pipes με τα οποία επιτυγχάνεται η επικοινωνία με τον ενδιάμεσο κόμβο intermediate του δέντρου διεργασιών. Φτιάχνω 2 πίνακες απο pipes , ο ένας myprime_pipes ,χρησιμοποιέιται για να λαμβάνει ζεύγη (αριθμος,χρόνος που απαιτήθηκε για να βρεθεί) και ο άλλος mytime_pipes για να λαμβάνει το πόσο χρόνο έκανε σε κάθε ενδιάμεσο κόμβο, κάθε worker για να εκτελεσθεί με επιτυχία.Στη συνέχεια , για κάθε ένα από τα παιδιά της διεργασίας αυτής, υπολογίζουμε το διάστημα προς αναζήτηση και κλείνουμε όλα τα pipes τα οποία δε χρειάζονται για την προκείμενη επικοινωνία. Στη συνέχεια καλέιται ο intermediate.
Μόλις τελειώσει με τα παιδιά, στο μέρος όπου ενεργεί ο πατέρας, κλεινουμε όλα τα pipes στα οποία γράφει ο πατέρας και αφήνουμε αυτά που διαβάζει. Έπειτα έχω ορίσει 2 πίνακες τύπου info.
1. countForChildren (1D) περιλαμβάνει πληροφορία για καθε παιδί intermediate, πόσους αριθμους βρήκε και σε πόσο χρόνο
2. finalNumbers(2D) περιλαμβάνει όλους τους πρώτους αριθμούς που βρήκε το πρόγραμμα και τους χρονους τους.
Στη συνέχεια, διαβάζουμε δεδομένα από τα pipes και τα βάζουμε στους αντίστοιχους πίνακες που ανέφερα παραπάνω.Μόλις γεμίσουν οι πίνακες πάω και συνθέτω τη λίστα.Απο εκει και κάτω αρχίζει να φτάνει το πρόγραμμα στο επιθυμητό αποτέλεσμα. Εκτυπώνω κάθε στοιχείο της λίστας ένα ένα. Έπειτα βρίσκω τους min/max χρόνους και τους εκτυπώνω και, τελος εκτυπώνω όλα τα υπόλοιπα μηνύματα.(χρόνο για κάθε worker)
Μόλις τελειώσουν αυτά αποδεσμέυουμε τη μνήμη και το πρόγραμμα έχει φτάσει στο τέλος του.




functions  σε αυτό το αρχείο, έχω κάποιες συναρτήσεις οι οποίες είναι κοινές για το πρόγραμμα αυτό , και χρησιμοποιούνται από πολλαπλά επίπεδα. Έχω ορίσει κάποιες print*** συναρτήσεις οι οποίες εκτυπώνουν κείμενο με χρώμα. Επίσης μέσα στο αρχείο αυτό περιλαμβάνεται η συνάρτηση με την οποία διαβάζω τα arguments στην myprime καθώς και συναρτήσεις που αρχικοποιούν και καταστρέφουν array απο pipes. 


Ήθελα να κάνω όλο το πρόγραμμα να λειτουργεί με δυναμική δέσμευση μνήμης, η υλοποίηση με χρήση στατικών δομών, έγινε για να πετύχω πιο νωρίς το αποτέλεσμα και είχα σκοπό να την αλλάξω αλλά, λόγω πολλαπών bugs σχετικα με την επικοινωνία μεταξύ των pipes,περάσαν οι μέρες και δεν πρόλαβα, εντός τελικής προθεσμίας να τα κάνω δυναμικά.


common_types.h κοινό αρχείο για όλα τα προγράμματα ,περιγράφει κάποιες συναρτήσεις της λίστας και την δομή  info.
